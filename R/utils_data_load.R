################################################
# Paper title:	Over half of the negative crop yield variability explained by anthropogenic indicators
# Authors:	Pekka Kinnunen*, Matias Heino, Vilma Sandstr√∂m, Maija Taka, Deepak K. Ray, Matti Kummu*
##
# Code author: Pekka Kinnunen
# Helper functions for data loading
#################################################

create_folder <- function(override_results = T) {
  # creates a folder for results and returns the path

  result_date <- Sys.Date()
  dir_name <- paste0("results/","results_",result_date )

  if (override_results) {
    print(paste("overriding old results from this date,", result_date))
    unlink(dir_name)
    }

  if (!dir.exists(dir_name)) {
       dir.create(dir_name)
    }
  return(dir_name)
}



fao_to_long_format <- function(data_in,
                               keep_unit = FALSE,
                               keep_area_code = FALSE,
                               keep_elem_code = FALSE) {

# transform fao data to long format
  remove_cols <- c("Area Code","Element Code","Unit")

  if (keep_unit) { remove_cols <- remove_cols[remove_cols != "Unit"]  }
  if (keep_area_code) { remove_cols <- remove_cols[remove_cols != "Area Code"]  }
  if (keep_elem_code) { remove_cols <- remove_cols[remove_cols != "Element Code"]  }

  col_names <- names(data_in)
  first_year <- col_names[min(which(startsWith(col_names,"Y")))]
  last_year <- col_names[max(which(startsWith(col_names,"Y") & !endsWith(col_names, "F")))]


  data_out <- data_in %>%
    dplyr::select( -c(ends_with("F"),all_of(remove_cols)))  %>%
    gather( key = "Year", value = "value" ,all_of(first_year):all_of(last_year)) %>%
    filter(Item != "Population") %>%
    mutate(Year = Year %>% str_replace("Y","") %>% as.numeric)

  return(data_out)
}



read_wri_waterstress <- function(path_to_data, ref_r) {

# read baseline waterstress from WRI Aqueduct data
  path_to_file <- 'Y2019M07D12_Aqueduct30_V01/baseline/annual/y2019m07d11_aqueduct30_annual_v01.gpkg'
  path_waterstress <- file.path(path_to_data, path_to_file)

  ws_cols <- c("string_id", "aq30_id","bws_score", "bws_cat")

  waterstress <- st_read(path_waterstress) %>%
    dplyr::select(all_of(ws_cols)) %>%
    mutate(bws_score = (5 - bws_score)/5)

  ws_r <- fasterize(sf =  waterstress,raster = ref_r, field = "bws_score", fun ="min")
  return(ws_r)
  }


is_raster <- function(r){
  # check if object is a raster

  obj <- class(r)

  if (obj[1] %in% c("RasterLayer","RasterStack","RasterBrick") ) {
    return(TRUE)
  } else {
    return(FALSE)
  }
}

raster_mean <- function(r, var_name) {
  out <- mean(r, na.rm =TRUE)
  names(out) <- var_name
  return(out)
}

read_fertilizer_consumption <- function(path_in,
                                        crop_name = "maize",
                                        data_source = "earthstat",
                                        fertilizer,
                                        years = c(1970:2015),
                                        cntry_sf = NA,
                                        cntry_names = NA)
  {
  ###
  # INPUTS:
  # path: path to data
  # fertilizer: select fertilizer type, currently only grand totals for N,P,K
  # years: analysis years
  # cntry_sf: shape for countries
  # cntry_names: tbl for corresponding names with fertilizer data

  # RETURNS:
  # raster_out: raster stack for specified variable and crop



  ## Fertilizer data, need to check that countries match between sf and data
  # does not match 100% currently
  # total consumptions of fertilizers

  fertilizer_names <- tibble(fertilizer = c("Nitrogen", "Phosphorus", "Potassium"),
                             abbrv =  c("N","P","K"),
                             IFA_name = c("Grand Total N","Grand Total P2O5","Grand Total K2O"))


  #assertthat::assert_that(length(fertilizer) == 1,
   #                       msg = "input fertilizer fractions one by one")


  # match rows in fertilizer_names
  has_name <- which(
    apply(fertilizer_names, c(1,2),
          function(fert) which( fert %in% fertilizer)) == 1,
    arr.ind = TRUE)

  select_fertilizers <- unique(has_name[,1])

  if (data_source == "earthstat") {
    fertilizer <- fertilizer_names[select_fertilizers, 1] %>%
      pull(fertilizer)

    #assertthat::assert_that(length(crop_name) == 1, msg = "too many crops")

    crop_fert_comb <- crossing(crop_name, fertilizer) %>%
      mutate(folder = paste0(path_in,"FertilizerCropSpecific_Geotiff/Fertilizer_", crop_name, "/"),
             file = paste(crop_name, fertilizer,sep = "_"),
             ending = "Application_Rate.tif",
             file_out = paste0(folder, file,ending),
             raster_name = paste(fertilizer,"layer", crop_name,sep = "_"))

    stack_out <- crop_fert_comb %>%
      pull(file_out) %>%
      stack()

    names(stack_out) <- crop_fert_comb %>% pull(raster_name)

    return(stack_out)

  } else {
    stop(" Other fertilizers not implemented")

  }
}


read_FAO_GAEZ <- function(path, crops = c("wheat","rice","maize","soybean"),
                          si_level = c("low","intermediate","high"),
                          verbose = FALSE)
  {
  #Loads FAO GAEZ suitability data
  ###
  # INPUTS:
  # path: path to GAEZ folder
  # crops: select crops
  # si_level: low, intermediate, high
  # RETURNS:
  # stack_out: raster stack for specified variable and crop

  ## WHAT TO DO WITH RICE?
  # inland dry rice
  # wetland rice

  #browser()

  variable = "SI"
  crops <-  unlist(lapply(as.list(crops),
                          function(x) if (x == "rice")  c("inland dry rice","wetland rice") else x)) %>%
    unique()

  crops <- gsub("soybean","soy",crops)



  abbrv_translate <- c( "mze" = "maize" ,
                        "rcw" = "rice",
                        "soy" = "soybean",
                        "whe" = "wheat")

  si_info <- read_csv(paste0(path, "SI_info.csv")) %>%
    filter(full_name %in% crops,
           SI_level %in% si_level) %>%
    mutate(crop_names = dplyr::recode(abbrv, !!!abbrv_translate ),
           name_out = paste(paste0("layer_SI",SI_level),crop_names, sep = "_"))

  if (verbose) print(si_info)

  si_files <- pull( si_info,file)

  name_out <- pull(si_info, name_out)

  path_to_si <- paste0(path, variable,"/",si_files)

  stack_out <- stack(path_to_si)

  names(stack_out) <- name_out


  return(stack_out)
}



read_hdi_gdp <- function(path, variable, years = seq(1990,2015))
  {
  ### read HDI and GDP data from Kummu et al. 2020 and Varis et al. 2019

  variable <- toupper(variable)

  # path to variable
  if (variable == "HDI") {
    path_to_data <- paste0(path, "HDI_GDP_Kummu_et_al_2020/HDI_1990_2015_v2.nc")
  }

  else if (variable == "GDPPPP") {
    path_to_data <- paste0(path, "HDI_GDP_Kummu_et_al_2020/GDP_PPP_1990_2015_5arcmin_v2.nc")
  }

  else if (variable == "GDPPERCAP") {
    path_to_data <- paste0(path, "HDI_GDP_Kummu_et_al_2020/GDP_per_capita_PPP_1990_2015_v2.nc")
  }

  else if (variable == "ADMIN_UNITS") {
    path_to_data <- paste0(path, "HDI_GDP_Kummu_et_al_2020/admin_areas_GDP_HDI.nc")
    admin_out <- stack(path_to_data)
    names(admin_out) <- c("admin_GDP", "admin_HDI")
    return(admin_out)
  }

  else if (variable == "GOVERNANCE") {
    path_to_data <- paste0(path,"Varis_et_al_2019/governance.nc")
  }

  nc_in <- nc_open(path_to_data)
  select_yrs <- ncvar_get(nc_in, "time") %in% years %>%
    which(.)
  nc_close(nc_in)

  if (length(select_yrs) == 0) {
    stop("No years selected")
  }

  stack_out <- stack(path_to_data,bands = select_yrs)
  return(stack_out)

}

change_resolution <- function(raster_in, res_to = 0.5, cfun = "mean")
  {

  resolution_in <- res(raster_in)
  resolution_change <- resolution_in / res_to
  if (all(resolution_change > c(1,1))) {

    raster_out <- raster::disaggregate(raster_in, resolution_change, method = "bilinear", na.rm = TRUE)

  }

  else if (all(resolution_change < c(1,1))) {

    resolution_change = 1/resolution_change
    raster_out <- raster::aggregate(raster_in, resolution_change, fun = cfun, na.rm = TRUE)

  } else {
    raster_out <- raster_in
  }

  return(raster_out)

}



read_irrigation <- function(path, years = seq(1990,2005,5))
  {
  # reads in irrigation data from Siebert et al. 2015

  years_all <- c(seq(1900, 1970,10), seq(1980,2005,5))

  # select years closest to years in irrigation dataset

  select_years <- sapply(years, FUN = function(x) {
    out <- which.min(abs(years_all - x))
    return(out)
  }) + 14

  sel_years <- unique(select_years)
  nyears <- table(select_years)

  nc_path <- paste0(path, "HID_aei_ha.nc")

  stack.irri <- brick(nc_path)
  stack.irri <- stack.irri[[sel_years]]

  stack.irri <- raster::t(stack.irri) %>%
    raster::flip(., "x")

  crs_in <- CRS("+proj=longlat +datum=WGS84 +no_defs")
  r_extent <- c(-180,180,-90,90)
  extent(stack.irri) <- r_extent
  crs(stack.irri) <- crs_in

  # to km2
  stack_area <- raster::area(stack.irri[[1]]) * 10*10

  stack.irri <- stack.irri/stack_area

  stack_out <- lapply(1:length(sel_years), function(x) {
    r <- stack.irri[[x]]
    s <- replicate(nyears[x], r)
    s <- stack(s)
    return(s)
  }) %>%
    stack()

  names(stack_out) <- paste0("X", years)

  return(stack_out)

}

read_shdi <- function(path, indices = c("ed","health","inc"), years = c(1990:2018)) {
  path_dir <- paste0(path, "/HDI_components_subnational_global_5arcmin_1990-2018/")
  years_all <- 1990:2018
  select_years <- years_all %in% years
  r_out <- list()
  for (ind in indices) {
    file_paths <- paste0(path_dir, "hdiComponent_",ind,"index.tif")
    tmp <- raster::stack(file_paths) %>%
      raster::subset(., which(select_years))
    names(tmp) <- paste0(ind, "_",years)

    if (length(indices) == 1) {
      r_out <- tmp
    } else {
      r_out[[ind]] <- tmp
    }
  }
  return(r_out)
}

make_analysis_unit <- function(...,
                              save_temp = FALSE,
                              filename = FALSE,
                              has_time = FALSE,
                              res_in = 0.5)
  {
  #constructs a raster for the spatial analysis unit
  # takes in spatial zonings (e.g. Holdridge zones) and performs intersection for the all

  ###
  # INPUTS:
  # ... :  zoning data (currently only in sf)
  # has_time:  TRUE if the zoning changes with time (not yet implemented)
  # resolution: raster output resolution

  # RETURNS:
  # raster_out: rasterised zones with zone ids as values
  # data_out: tibble with zoning ids and classification

  ###
  # TODO:
  # check CRS of input
  # implement changing time
  # multiple layers
  ####

  dots <- list(...)
  ndots <- length(dots)
  tempRaster <- raster::raster(nrow = 180/res_in, ncol = 360/res_in,
                      xmn = -180,xmx = 180, ymn = -90, ymx = 90)
  library(rlist)
  raster_out <- list()
  data_list <- list()

  namesRasterObjs <- c("RasterStack","RasterLayer","RasterBrick")

  # single layer
  if (ndots == 1) {
    lyr <- dots[[1]]
    lyr_class <- class(lyr)[1]

    if (lyr_class %in% namesRasterObjs) {

      writeRaster(lyr, "temp_data/analysis_unit.tif", overwrite = TRUE)

      return(lyr)

    } else {
      lyr <- lyr %>%
        mutate(ID = row_number()) %>%
        st_cast("MULTIPOLYGON")

      raster_out <- fasterize(lyr, tempRaster,field = "ID")
      data_out <- st_drop_geometry(lyr)
      }

    # multiple layers
    } else if (ndots == 2) {

      stop()

      ndots_classes <- lapply(dots, function(x) class(x)[1] == "sf")

      assertthat::assert_that(all(ndots_classes == TRUE),
                              msg = "check analysis unit input data")

      r_stack <- raster::stack()
      data_list <- list()

      for (nlyr in 1:ndots) {

        lyr <- dots[[nlyr]] %>%
          mutate(ID = row_number()) %>%
          st_cast("MULTIPOLYGON")

        lyr_class <- class(lyr)
        raster_out <- fasterize(lyr, tempRaster,field = "ID")
        data_out <- st_drop_geometry(lyr)

        r_stack <- stack(r_stack, raster_out)
        data_list[[nlyr]]  <- data_out
        }


      stack_vals <- getValues(r_stack) %>%
        as_tibble()  %>%
        group_by_all() %>%
        summarise(.groups = "drop") %>%
        ungroup() %>%
        drop_na() %>%
        mutate(ID = row_number())

      raster_out <- tempRaster

      # find the locations of the new IDs
      for (row_id in 1:nrow(stack_vals)) {

        logic_lyr1 <- r_stack[[1]] == stack_vals$layer.1[row_id]
        logic_lyr2 <- r_stack[[2]] == stack_vals$layer.2[row_id]

        raster_out[logic_lyr1 & logic_lyr2] <- stack_vals$ID[row_id]

      }

      # join ID data together
      data_out <- stack_vals %>%
        left_join(data_list[[1]], by = c("layer.1" = "ID"))%>%
        left_join(data_list[[2]], by = c("layer.2" = "ID" )) %>%
        ungroup()

    }
  path_out  <- FALSE
  if (save_temp) {
    if (isFALSE(filename)) {
      name_out <- "temp_data/analysis_unit.tif"
    } else {
      name_out <- filename
    }

    writeRaster(raster_out, name_out, overwrite = TRUE)

    path_out <- name_out
  }


  list_out <- list(raster_out, data_out, path_out)
  return(list_out)
}

standardize_raster <- function(x)
  {
  r_mean <- cellStats(x, mean,na.rm = T)
  r_sd <- cellStats(x,sd, na.rm = T)
  x <- (x - r_mean)/r_sd
  return(x)
  }


data_to_analysis_unit <- function(data_in,
                                  aunit_raster,
                                  aunit_data,
                                  indicator_name =NULL,
                                  cfun = "mean",
                                  areaWeigth = FALSE )
{
  # transforms data into analysis unit scale
  ###
  # Input:
  # raster_in: raster or list of raster obj of input data
  # aunit: raster of input_data
  # aunit_data: tibble with zoning data
  # indicator_name: name of the value of input data
  # cfun: function to aggregate data to analysis unit

  # Returns:
  # data_out = tibble with data for each analysis unit

  ###

  rasterObjs <- c("RasterLayer","RasterStack","RasterBrick")

  assertthat::assert_that(class(data_in)[1] %in% rasterObjs,
                          msg = "Input data in wrong format, should be a raster obj")

  raster_in <- data_in

  # single analysis unit
  names(aunit_raster) <- "zones"
  raster_in <- stack(aunit_raster, raster_in)

  data_temp <- raster::zonal(raster_in, aunit_raster, fun =  cfun, na.rm = TRUE ) %>%
    as_tibble() %>%
    dplyr::select(-zone) %>%
    pivot_longer(cols = -zones,
                 names_to = "lyr_name", values_to = "value") %>%
    drop_na() %>%
    separate("lyr_name",into = c("indicator","Year","crop_name"),
             sep = "_", remove = T)

  if (!is.null(indicator_name)) {
    data_temp <- mutate(data_temp, indicator = indicator_name)
  }


  if (areaWeigth) {
    id_weights <- raster::zonal(area(aunit_raster), aunit_raster, fun = "sum", na.rm = TRUE) %>%
      as_tibble()

    data_temp <- data_temp %>%
      left_join(id_weights, by = c(zones, zone)) %>%
      mutate(value = value / sum )
  }

  data_out <- left_join(data_temp, aunit_data, by = c("zones" = "gridCell") )

  return(data_out)
}

do_raster_pca <- function(raster_in, indicatorPCA, nPCA)
  {

  lyr_names <- names(raster_in)
  crops_all <- lyr_names %>%
    str_split(pattern = "_", simplify = T) %>%
    .[,3] %>%
    unique()

  stack_pca <- raster::stack()
  for (crop_select in crops_all) {

    lyr_select <- lyr_names[str_detect(lyr_names, crop_select)]
    s_in <- standardize_raster(raster_in[[lyr_select]])

    pca_out <-  s_in %>%
      RStoolbox::rasterPCA(., nComp = nPCA, spca = TRUE)

    pca_names <- paste(indicatorPCA,
                       names(pca_out$map),
                       crop_select,
                       sep = "_")

    names(pca_out$map) <- pca_names

    stack_pca <- stack(stack_pca, pca_out$map)

    print(paste("PCA Summary for", crop_select, indicatorPCA))
    print(summary(pca_out$model))

  }
  raster_in <- stack_pca
}

rect_data_to_raster <- function(data_in,
                                raster_in,
                                area_names,
                                join_name_data,
                                join_name_raster,
                                take_mean = FALSE)
  {

  # rectangle data to raster

  col_names <- colnames(data_in)

  years <- data_in %>%
    pull(Year) %>%
    unique()

  indicators <- data_in %>%
    pull(indicator) %>%
    unique()

  data_in <- left_join(data_in, area_names,
                       by = setNames(nm = join_name_data,join_name_raster))
  data_in <- data_in %>%
    drop_na()


  all_ids <- unique(values(raster_in))

  list_out <- list()

  for (indicator_name in indicators) {

    temp_stack <- list()

    for (year_in in years) {

      temp_data <-  data_in %>%
        ungroup() %>%
        filter(indicator == indicator_name,Year == year_in) %>%
        dplyr::select(cntry_id, value) %>%
        filter(!is.na(cntry_id)) %>%
        as.matrix()

      sel_ids <- unique(temp_data[,1])
      is_missing <- all_ids[!all_ids  %in% sel_ids]

      missing_data <- tibble(id = is_missing, value = NA) %>%
        filter(!is.na(id)) %>%
        as.matrix()

      temp_data <- rbind(temp_data, missing_data )

      data_raster <- reclassify(raster_in, temp_data, include.lowest = TRUE)

      year_id  <- paste0("X",year_in)
      names(data_raster) <- year_id
      temp_stack[[year_id]] <- data_raster
    }

    temp_stack <- stack(temp_stack)

    if (take_mean) {
      temp_stack <- mean(temp_stack, na.rm = TRUE)
    }

    if (length(indicators)>1) {
      list_out[[indicator_name]] <- temp_stack
    } else {
      list_out <- temp_stack
    }

  }

  return(list_out)
}

norm_values <- function(x, probs = c(0, 1)) {

  x_range <- quantile(x, probs = probs , na.rm = T)

  if (all(class(x_range) == "numeric")) {
    dim(x_range) <- c(1, length(probs))
  }

  x_low <- x_range[,1]
  x_high <- x_range[,2]

  if (class(x)[1] %in% c("RasterStack", "RasterBrick","RasterLayer")) {

   out <- lapply(1:nlayers(x), function(y) {
      tt <- x[[y]]
      tt[tt < x_low[[y]] ] <- x_low[y]
      tt[tt > x_high[[y]]] <- x_high[y]
      out <- (tt - x_low[y]) / (x_high[y] - x_low[y])
      return(out)
    }) %>% stack()
  } else {
    x[x <= x_low] <- x_low
    x[x >= x_high ] <- x_high
    out <- (x - x_low) / (x_high - x_low)
  }
  return(out)
}


load_crop_data <- function(crop_names = c("maize","wheat","soybean","rice"),
                           path_crop_data,
                           years,
                           var_name = "yield",
                           temp_raster,
                           output = "weights") {

  r_output <- stack()

  for (crop_name in crop_names) {

    path_in <- paste0(path_crop_data , crop_name , "_data_1970to2013/")
    crop_var = import_ray_crop_data(path_in, var_name, dtype_out = "array")
    years_all = c(1971:2013)

    select_years = years_all %in% years
    nlyr = sum(select_years)

    crop_var_select = crop_var[,,select_years]

    r_brick <- raster::brick(temp_raster,nl = nlyr)
    r_brick <- setValues(r_brick, crop_var_select)
    names(r_brick) = paste0("year", years)

    r_mean <- mean(r_brick, na.rm = TRUE)
    r_output <- stack(r_output, r_mean)

  }


  if (output == "weights") {
    r_output[r_output>0] <- 1
    r_output[r_output == 0] <- NA

  }

  names(r_output) <- crop_names

  return(r_output)

}

mask_by_crop_areas <- function(data_in,
                                 crop_data)
  {
    crop_names <- names(crop_data)
    data_names <- names(data_in) %>%
      str_split(., "_",3, simplify = T)
    data_out <- stack()

    for (i in 1:nrow(data_names)) {


      # if (data_names[i,2] == "") {
      #   lyr_info <- data_names[i,1]
      # } else {
      #   lyr_info <- paste(data_names[i,1:2], collapse = "_")
      # }
      # collapse indicator name and year data
      lyr_info <- paste(data_names[i,1:2], collapse = "_")
      if (data_names[i,3] == "") {

        s_temp <- crop_data*data_in[[i]]

        s_temp[is.na(s_temp) & crop_data == 1] <- 0

        names(s_temp)  <- paste(lyr_info, crop_names, sep = "_")

        data_out <- stack(data_out,s_temp )
      } else {

        crop_temp <- data_names[i,3]
        r_temp <- crop_data[[crop_temp]] * data_in[[i]]
        r_temp[is.na(r_temp) & crop_data[[crop_temp]] == 1] <- 0

        names(r_temp) <- paste(lyr_info, crop_temp, sep = "_")

        data_out <- stack(data_out, r_temp)
      }
  }

    return(data_out)
}


tidydata_as_raster <- function(data_in, indicator_col, area_id_col = "cell_id",
                                value_col = "value", ref_raster,...) {

  dots <- list(...)

  indicator_values <- data_in %>%
    pull(all_of(indicator_col)) %>%
    unique()

  s_out <- stack()
  for (ind in indicator_values) {
    df <- data_in %>%
      dplyr::filter(!!sym(indicator_col) == ind)

    ids <- df %>%
      pull(all_of(area_id_col)) %>%
      unique()

    rtemp <- ref_raster
    rtemp[!rtemp %in% ids] <- NA

    rcl <- df %>%
      ungroup() %>%
      dplyr::select(all_of(c(area_id_col, value_col))) %>%
      as.matrix()

    rtemp <- raster::reclassify(rtemp, rcl)
    names(rtemp) <- ind

    s_out <- stack(s_out, rtemp)
  }

  # plot
  if (!is.null(dots$plot)) {
    raster::plot(s_out)
  }
  return(s_out)
}

fill_na_values <- function(s_in, ref_raster, max_distance = 3 , ncores = 1) {
  # get nearest non_na cells (within a maximum step distance)
  # max_distance is the number steps in neighborhood matrix

  ## TO DO:
  # check raster has same extent etc.
  # mapunits to actual distance?

  nlyr  <- nlayers(s_in)

  print(nlyr)
  s_out <- stack()
  for (i in 1:nlyr) {
    print(i)
    raster_in <- s_in[[i]]
    # areas to fill
    fill_areas <- (!is.na(ref_raster)) & (is.na(raster_in))
    plot(fill_areas, main = "areas to fill")

    #
    points <- raster::Which(fill_areas > 0, cells = TRUE)
    print(paste0("fill n = ",length(points)," points" ))
    all_ids <- 1:raster::ncell(raster_in)
    adj <- raster::adjacent(x = raster_in, cells = all_ids, directions = 8)

    has_value <- Which(!is.na(raster_in), cells = T)
    adj <- adj[!(adj[,1] %in% has_value), ]

    no_area <- raster::Which( is.na(ref_raster) & is.na(raster_in), cells = T)

    adj <- adj[!(adj[,1] %in% no_area),]

    r_out <- raster_in

    doParallel::registerDoParallel(cores = ncores)
    out <- foreach(p = 1:length(points), .combine = c) %dopar% {
      p_in <- points[p]
      pdist <- 0
      start_c <- p_in
      start_p <- xyFromCell(raster_in, start_c)
      neighbors  <- adj[adj[,1] == start_c,2]

      while (pdist < max_distance) {
        pdist <- pdist + 1
        # neighbors
        pot_vals  <- raster_in[neighbors]
        test_val <- !is.na(pot_vals)

        if (sum(test_val) == 1) {
          #r_out[start_c] <- pot_vals[!is.na(pot_vals)]

          return(neighbors[test_val])

        } else if (sum(test_val) > 1) {
          # calc distance
          coords <- raster::xyFromCell(raster_in, neighbors[test_val])
          dists <- sqrt((coords[, 1] - start_p[1,1]) ^ 2 +
                          (coords[, 2] - start_p[1,2]) ^ 2)

          min_dist <- which.min(dists)
          cell_select <- neighbors[test_val][min_dist]
          #r_out[start_c] <- raster_in[cell_select]
          return(cell_select)

        } else {
          neighbors <- unique( adj[(adj[,1] %in% neighbors),2] )

        }
      }
      # return NA if no cells are found
      return(NA)
    }

    doParallel::stopImplicitCluster()

    refs <- cbind(points, out)

    no_vals <- refs[is.na(refs[,2]), 1]
    print(paste0("points w/o value ", length(no_vals)))

    r_novals <- raster(ref_raster)
    values(r_novals) <- all_ids
    r_novals[!r_novals %in% no_vals] <- 0
    r_novals[r_novals %in% no_vals] <- 1
    plot(r_novals, main = "areas without value")

    refs <- refs[!is.na(out),]

    r_out[refs[,1]] <- raster_in[refs[,2]]
    s_out <- stack(s_out, r_out)
  }
  return(s_out)
}
